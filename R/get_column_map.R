#' Get Column Map
#' @details This function retuns a dataset describing the columns exported
#' by qualtrics. Some columns describe how the data export looks (ex: \code{column_exported}), others give information
#' about the columns (ex: \code{column_number}), and others yet give suggested
#' renaming conventions (ex: \code{column_harmonized}). The columns return have these meanings:
#' \itemize{
#'  \item \code{column_exported}: column names of data exported generated using
#'  \code{file_format}
#'  \item \code{column_harmonized}: suggested new name generated by combining
#'   \code{question_name} and \code{suffix}
#'  \item \code{variable_label_exported}: column label exported
#'  \item \code{variable_label_exported}: column label derived
#'  \item \code{question_export_tag}, \code{column_export_tag}, \code{subq_export_tag} : associated export tags
#'  \item \code{question_id}: internal Qualtrics question id
#'  \item \code{import_id}: metadata from the 3rd row of CSV exports
#'  \item \code{question_name}: derived question name, made by using the position
#'  within the block.
#'  \item \code{suffix}: suffix created by question characteristics
#'  \item \code{loop_number}: loop number from "loop and merge" questions
#'  \item \code{column_number}: column within side-by-side questions
#'  \item \code{subq_number}: sub-question number within matrix or side-by-side questions
#'  \item \code{choice}: internal choice number from multiple choice questions
#'  \item \code{choice_recode}: choice recode value
#'  \item \code{text_entry}: binary representation of whether the choice
#'  allows text entry. Note that this comes from the \code{import_id}, not whether
#'  the column literally contains text entry data.
#' }
#' @note Uses \code{qualtreats::get_responses} to fetch the exported header.
#' @param survey_id string of the survey id, begins with 'SV_'
#' @param file_format one of \code{c('spss', 'csv', 'tsv')}
#' @return a \code{tibble} containing information about the columns exported
#' by the survey associated with \code{survey_id}
#' @author Sven Halvorson (svenpubmail@gmail.com)
#' @export

get_column_map = function(
    survey_id,
    file_format = c('spss', 'csv', 'tsv')
){

  # argument checks:
  stopifnot(
    all(
      valid_survey_id(survey_id),
      valid_api_key(Sys.getenv('QUALTRICS_API_KEY')),
      valid_base_url(Sys.getenv('QUALTRICS_BASE_URL'))
    )
  )
  file_format = rlang::arg_match(file_format)

  # Flatten the survey, get the simplified question types:
  survey_flat = qualtreats::flatten_survey(survey_id)
  qtypes = qualtreats::simplify_qtypes(survey_flat = survey_flat)


  # Get exported columns ----------------------------------------------------

  # Get the exported column names and associated columns:
  exported_columns = suppressMessages(
    qualtreats::get_responses(
      survey_id = survey_id,
      file_format = file_format,
      trim_rows = FALSE,
      limit = 0
    )
  ) %>%
    dplyr::select(-(StartDate:UserLanguage))

  # Have to re-do it if file_format == 'spss' since it doesn't give metadata:
  if(file_format == 'spss'){

    exported_metadata = suppressMessages(
      qualtreats::get_responses(
        survey_id = survey_id,
        file_format = 'csv',
        trim_rows = FALSE,
        limit = 0
      )
    ) %>%
      dplyr::select(-(StartDate:UserLanguage)) %>%
      dplyr::slice(2) %>%
      as.character()

    variable_label_exported = purrr::map_chr(
      .x = exported_columns,
      .f = attr,
      'label'
    )

  }else {
    exported_metadata = as.character(dplyr::slice(exported_columns, 2))
    variable_label_exported = as.character(dplyr::slice(exported_columns, 1))
  }


  # Start making the table of exported columns and their features.
  # Want these elements:
  # question_id, qtype, matrix, sbs, export_tags
  get_exported_choice = function(x){
    as.integer(purrr::pluck(jsonlite::fromJSON(x), 'choiceId', .default = NA_character_))
  } # This only seems to get the checkbox questions

  get_variable_label = function(x){
    purrr::pluck(jsonlite::fromJSON(x), 'ImportId', .default = NA_character_)
  }

  column_map = tibble::tibble(
    column_exported = colnames(exported_columns),
    variable_label_exported = variable_label_exported,
    import_id = purrr::map_chr(
      .x = exported_metadata,
      .f = get_variable_label
    ),
    question_id = stringr::str_extract(
      string = import_id,
      pattern = 'QID[0-9]+'
    ),
    choice_recode = purrr::map_int(
      .x = exported_metadata,
      .f = get_exported_choice
    )
  )

  # Set aside for error check:
  column_map_nrow = nrow(column_map)

  #  Loop number ------------------------------------------------------------

  # The first thing I want to do is mark the loops. This is because
  # it's used as a prefix to the export tag
  loop_question_ids = qtypes %>%
    dplyr::filter(question_loop == 1L) %>%
    dplyr::pull(question_id)

  column_map = column_map %>%
    dplyr::mutate(
      loop_number = dplyr::case_when(
        question_id %in% loop_question_ids ~ stringr::str_extract(
          string = import_id,
          pattern = '^[0-9]+_'
        )
      ),
      loop_number = as.integer(
        stringr::str_extract(
          string = loop_number,
          pattern = '[0-9]+'
        )
      ),
      # suffix will be the piece we keep grinding down and extracting from:
      suffix = dplyr::case_when(
        question_id %in% loop_question_ids ~ stringr::str_remove(
          string = import_id,
          pattern = '^[0-9]+_'
        ),
        TRUE ~ import_id
      ),
      suffix = stringr::str_remove(
        string = suffix,
        pattern = 'QID[0-9]+_?'
      )
    )




  # Column number ----------------------------------------------------------

  # We might be able to get away with recognizing pound signs
  # but let's try to not infer which questions are sbs:
  sbs_question_ids = qtypes %>%
    dplyr::filter(question_sbs == 1L) %>%
    dplyr::pull(question_id)

  column_map = column_map %>%
    dplyr::mutate(
      column_number = dplyr::case_when(
        question_id %in% sbs_question_ids ~ stringr::str_extract(
          string = suffix,
          pattern = '^#[0-9]+_'
        )
      ),
      column_number = as.integer(
        stringr::str_extract(
          string = column_number,
          pattern = '[0-9]+'
        )
      ),
      suffix = dplyr::case_when(
        question_id %in% sbs_question_ids ~ stringr::str_remove(suffix, '^#[0-9]+_'),
        TRUE ~ suffix
      )
    )

  # little check in case we don't understand this export schema as well as we think:
  if(
    any(
      stringr::str_detect(
        string = column_map[['suffix']],
        pattern = '#'
      )
    )
  ){
    stop('residual pound signs found in suffix')
  }


  # SubQuestions ------------------------------------------------------------

  matrix_question_ids = qtypes %>%
    dplyr::filter(question_matrix == 1L) %>%
    dplyr::pull(question_id)

  column_map = column_map %>%
    dplyr::mutate(
      subq_number = dplyr::case_when(
        question_id %in% matrix_question_ids ~ stringr::str_extract(
          string = suffix,
          pattern = '^[0-9]+_?'
        )
      ),
      subq_number = as.integer(
        stringr::str_extract(
          string = subq_number,
          pattern ='[0-9]+'
        )
      ),
      suffix = dplyr::case_when(
        question_id %in% matrix_question_ids ~ stringr::str_remove(suffix, '^[0-9]+_?'),
        TRUE ~ suffix
      )
    )


  # Choices -----------------------------------------------------------------

  # last part! Think I'm content to just assume any leftover numbers
  # in the suffix are choices:

  column_map = column_map %>%
    dplyr::mutate(
      choice = stringr::str_extract(
        string = suffix,
        pattern = '^[0-9]+_?'
      ),
      choice = as.integer(
        stringr::str_extract(
          string = choice,
          pattern ='[0-9]+'
        )
      ),
      suffix = stringr::str_remove(
        string = suffix,
        pattern = '^[0-9]+_?'
      )
    )

  # Now we need to join BOTH the choices and the choice_recodes because
  # for whatever reason Qualtrics exports both in differen circumstances:
  column_map = column_map %>%
    dplyr::left_join(
      dplyr::transmute(
        survey_flat[['choices']],
        question_id,
        column_number,
        choice,
        choice_recode2 = choice_recode
      ),
      by = c('question_id', 'column_number', 'choice')
    )

  column_map = column_map %>%
    dplyr::left_join(
      dplyr::transmute(
        survey_flat[['choices']],
        question_id,
        column_number,
        choice2 = choice,
        choice_recode
      ) %>%
        dplyr::filter(!is.na(choice_recode)),
      by = c('question_id', 'column_number', 'choice_recode')
    ) %>%
    dplyr::mutate(
      choice_recode = dplyr::coalesce(choice_recode, choice_recode2),
      choice = dplyr::coalesce(choice, choice2),
      choice = dplyr::coalesce(choice, choice_recode)
    )


  # Shouldn't be any numbers remaining as far as I know:
  if(
    any(
      stringr::str_detect(
        string = column_map[['suffix']],
        pattern = '[0-9]'
      )
    )
  ){
    stop('residual numbers found in suffix')
  }


  # Text entry --------------------------------------------------------------

  text_question_ids = qtypes %>%
    dplyr::filter(question_style == 'text') %>%
    dplyr::pull(question_id)

  column_map = column_map %>%
    dplyr::mutate(
      text_entry = as.integer(
        stringr::str_detect(
          string = suffix,
          pattern = 'TEXT'
        )
       & (!question_id %in% text_question_ids | question_id %in% sbs_question_ids)
      ),
      suffix = stringr::str_remove(
        string = suffix,
        pattern = 'TEXT'
      )
    )


  # Nice suffix -------------------------------------------------------------

  # now we use all that data we extracted to make the coded suffix:
  column_map = column_map %>%
    dplyr::mutate(
      LP = dplyr::case_when(
        !is.na(loop_number) ~ paste0('_LP', pad2(loop_number)),
        TRUE ~ ''
      ),
      CL = dplyr::case_when(
        !is.na(column_number) ~ paste0('_CL', pad2(column_number)),
        TRUE ~ ''
      ),
      SQ = dplyr::case_when(
        !is.na(subq_number) ~ paste0('_SQ', pad2(subq_number)),
        TRUE ~ ''
      ),
      CH = dplyr::case_when(
        !is.na(dplyr::coalesce(choice_recode, choice)) ~ paste0(
          '_CH', pad2(dplyr::coalesce(choice_recode, choice))
        ),
        TRUE ~ ''
      ),
      TEXT = dplyr::case_when(
        text_entry == 1 ~ '_TEXT',
        TRUE ~ ''
      ),
      suffix = dplyr::case_when(
        suffix != '' ~ paste0('_', suffix),
        TRUE ~ ''
      ),
      suffix = paste0(LP, CL, SQ, CH, TEXT, suffix)
    )


  # Export tags -------------------------------------------------------------

  column_map = column_map %>%
    dplyr::left_join(
      y = dplyr::select(
        survey_flat[['questions']],
        question_id,
        question_export_tag,
        column_export_tag,
        subq_export_tag,
        column_number,
        subq_number
      ),
      by = c('question_id', 'column_number', 'subq_number')
    )

  # Question names -------------------------------------------------------------

  # Now we're on to styling up our custom names:
  question_names = survey_flat[['blocks']] %>%
    dplyr::select(block_description, block_id) %>%
    dplyr::left_join(
      y = dplyr::select(survey_flat[['questions']], question_id, block_id, question_type),
      by = 'block_id'
    ) %>%
    # Descriptive boxes aren't exported:
    dplyr::filter(question_type != 'DB') %>%
    # repeats on column_number and subq_number mean we wanna grind this down:
    dplyr::distinct(block_description, block_id, question_id) %>%
    dplyr::group_by(block_id) %>%
    dplyr::mutate(
      question_num = pad2(dplyr::row_number())
    ) %>%
    dplyr::ungroup() %>%
    dplyr::transmute(
      question_name = paste0(
        block_description,
        '_',
        question_num
      ),
      question_id
    )

  column_map = dplyr::right_join(
    x = question_names,
    y = column_map,
    by = 'question_id'
  )


  # Prettier variable labels ------------------------------------------------

  # TODO: signature suffixes are gone
  # I'm finding that the variable labels exported both have unnecessary junk
  # in them but also have truncated text. Let's see if we can pretty them up
  # a bit:

  var_labs_harmonized = survey_flat[['questions']] %>%
    dplyr::transmute(
      question_id,
      column_number,
      subq_number,
      question_description = format_description(question_text),
      column_description = format_description(column_description),
      subq_description = format_description(subq_description)
    )

  # Add to the columns exported:
  var_labs_harmonized = column_map %>%
    dplyr::transmute(
      column_exported,
      question_id,
      column_number,
      subq_number,
      choice_join = dplyr::coalesce(choice_recode, choice),
      text_entry
    ) %>%
    dplyr::left_join(
      y = var_labs_harmonized,
      by = c('question_id', 'column_number', 'subq_number')
    )

  # add choice descriptions and make the variable label:
  var_labs_harmonized = survey_flat[['choices']] %>%
    dplyr::transmute(
      question_id,
      column_number,
      choice_description = format_description(choice_description),
      choice_join = dplyr::coalesce(choice_recode, choice)
    ) %>%
    dplyr::right_join(
      y = var_labs_harmonized,
      by = c('question_id', 'column_number', 'choice_join')
    ) %>%
    dplyr::mutate(
      text_suffix = ifelse(
        text_entry == 1,
        ' - Text',
        ''
      ),
      dplyr::across(
        .cols = c('column_description', 'subq_description', 'choice_description'),
        .fns = function(x){
          dplyr::case_when(
            is.na(x) ~ '',
            TRUE ~ paste0(' - ', x)
          )
        }
      ),
      variable_label = paste0(
        question_description,
        column_description,
        subq_description,
        choice_description,
        text_suffix
      )
    )

  column_map = column_map %>%
    dplyr::left_join(
      y = dplyr::select(
        var_labs_harmonized,
        column_exported,
        variable_label
      ),
      by = 'column_exported'
    )

  # Clean up ----------------------------------------------------------------

  # now we just attach the question name and suffix
  column_map = column_map %>%
    dplyr::transmute(
      column_exported,
      column_harmonized = paste0(question_name, suffix),
      variable_label_exported,
      variable_label,
      question_export_tag,
      column_export_tag,
      subq_export_tag,
      question_id,
      import_id,
      question_name,
      suffix,
      loop_number,
      column_number,
      subq_number,
      choice,
      choice_recode,
      text_entry
    )


  # Check -------------------------------------------------------------------

  if(nrow(column_map) != column_map_nrow){
    stop('number of rows in column_map is off!')
  }

  column_map

}





