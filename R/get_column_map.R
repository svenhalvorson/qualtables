#' Get Column Map
#' @details This function retuns a dataset describing the columns exported
#' by qualtrics. The columns return have these meanings:
#' \itemize{
#'  \item \code{exported_column}: column names of data exported generated using
#'  \code{file_format}
#'  \item \code{default_column}: suggested new name generated by combining
#'   \code{question_name} and \code{suffix}
#'  \item \code{exported_description}: question description
#'  \item \code{question_id}: internal Qualtrics question id
#'  \item \code{import_id}: metadata from the 3rd row of CSV exports
#'  \item \code{question_name}: derived question name, made by using the position
#'  within the block.
#'  \item \code{suffix}: suffix created by question characteristics
#'  \item \code{loop_number}: loop number from "loop and merge" questions
#'  \item \code{column_number}: column within side-by-side questions
#'  \item \code{subq_number}: sub-question number within matrix or side-by-side questions
#'  \item \code{choice}: internal choice number from multiple choice questions
#'  \item \code{choice_recode}: choice recode value
#'  \item \code{text_entry}: binary representation of whether the choice
#'  allows text entry. Note that this comes from the \code{import_id}, not whether
#'  the column literally contains text entry data.
#' }
#' @note Uses \code{qualtreats::get_responses} to fetch the exported header.
#' @param survey_id string of the survey id, begins with 'SV_'
#' @param file_format one of \code{c('spss', 'csv', 'tsv')}
#' @return a \code{tibble} containing information about the columns exported
#' by the survey associated with \code{survey_id}
#' @author Sven Halvorson (svenpubmail@gmail.com)
#' @export

get_column_map = function(
    survey_id,
    file_format = c('spss', 'csv', 'tsv')
){

  # argument checks:
  stopifnot(
    all(
      valid_survey_id(survey_id),
      valid_api_key(Sys.getenv('QUALTRICS_API_KEY')),
      valid_base_url(Sys.getenv('QUALTRICS_BASE_URL'))
    )
  )
  file_format = rlang::arg_match(file_format)

  # Flatten the survey, get the simplified question types:
  flattened_survey = qualtreats::flatten_survey(survey_id)
  qtypes = qualtreats::simplify_qtypes(flattened_survey = flattened_survey)


  # Get exported columns ----------------------------------------------------

  # Get the exported column names and associated columns:
  exported_columns = qualtreats::get_responses(
    survey_id = survey_id,
    file_format = file_format,
    trim_rows = FALSE,
    limit = 0
  ) %>%
    dplyr::select(-(StartDate:UserLanguage))

  # Have to re-do it if file_format == 'spss' since it doesn't give metadata:
  if(file_format == 'spss'){
    exported_metadata = qualtreats::get_responses(
      survey_id = survey_id,
      file_format = 'csv',
      trim_rows = FALSE,
      limit = 0
    ) %>%
      dplyr::select(-(StartDate:UserLanguage)) %>%
      dplyr::slice(2) %>%
      as.character()
    exported_descriptions = purrr::map_chr(
      .x = exported_columns,
      .f = attr,
      'label'
    )
  }else {
    exported_metadata = as.character(dplyr::slice(exported_columns, 2))
    exported_descriptions = as.character(dplyr::slice(exported_columns, 1))
  }


  # Start making the table of exported columns and their features.
  # Want these elements:
  # question_id, qtype, matrix, sbs, export_tags
  get_exported_choice = function(x){
    as.integer(subset_safely(jsonlite::fromJSON(x), 'choiceId'))
  } # This only seems to get the

  get_exported_description = function(x){
    subset_safely(jsonlite::fromJSON(x), 'ImportId')
  }

  column_map = tibble::tibble(
    exported_column = colnames(exported_columns),
    exported_description = exported_descriptions,
    import_id = purrr::map_chr(
      .x = exported_metadata,
      .f = get_exported_description
    ),
    question_id = stringr::str_extract(
      string = import_id,
      pattern = 'QID[0-9]+'
    ),
    choice_recode = purrr::map_int(
      .x = exported_metadata,
      .f = get_exported_choice
    )
  )

  # Set aside for error check:
  column_map_nrow = nrow(column_map)

  #  Loop number ------------------------------------------------------------

  # The first thing I want to do is mark the loops. This is because
  # it's used as a prefix to the export tag
  loop_question_ids = qtypes %>%
    dplyr::filter(question_loop == 1L) %>%
    dplyr::pull(question_id)

  column_map = column_map %>%
    dplyr::mutate(
      loop_number = dplyr::case_when(
        question_id %in% loop_question_ids ~ stringr::str_extract(
          string = import_id,
          pattern = '^[0-9]+_'
        )
      ),
      loop_number = as.integer(
        stringr::str_extract(
          string = loop_number,
          pattern = '[0-9]+'
        )
      ),
      # suffix will be the piece we keep grinding down and extracting from:
      suffix = dplyr::case_when(
        question_id %in% loop_question_ids ~ stringr::str_remove(
          string = import_id,
          pattern = '^[0-9]+_'
        ),
        TRUE ~ import_id
      ),
      suffix = stringr::str_remove(
        string =suffix,
        pattern = 'QID[0-9]+_?'
      )
    )




  # Column number ----------------------------------------------------------

  # We might be able to get away with recognizing pound signs
  # but let's try to not infer which questions are sbs:
  sbs_question_ids = qtypes %>%
    dplyr::filter(question_sbs == 1L) %>%
    dplyr::pull(question_id)

  column_map = column_map %>%
    dplyr::mutate(
      column_number = dplyr::case_when(
        question_id %in% sbs_question_ids ~ stringr::str_extract(
          string = suffix,
          pattern = '^#[0-9]+_'
        )
      ),
      column_number = as.integer(
        stringr::str_extract(
          string = column_number,
          pattern = '[0-9]+'
        )
      ),
      suffix = dplyr::case_when(
        question_id %in% sbs_question_ids ~ stringr::str_remove(suffix, '^#[0-9]+_'),
        TRUE ~ suffix
      )
    )

  # little check in case we don't understand this export schema as well as we think:
  if(
    any(
      stringr::str_detect(
        string = column_map[['suffix']],
        pattern = '#'
      )
    )
  ){
    stop('residual pound signs found in suffix')
  }


  # SubQuestions ------------------------------------------------------------

  matrix_question_ids = qtypes %>%
    dplyr::filter(question_matrix == 1L) %>%
    dplyr::pull(question_id)

  column_map = column_map %>%
    dplyr::mutate(
      subq_number = dplyr::case_when(
        question_id %in% matrix_question_ids ~ stringr::str_extract(
          string = suffix,
          pattern = '^[0-9]+_?'
        )
      ),
      subq_number = as.integer(
        stringr::str_extract(
          string = subq_number,
          pattern ='[0-9]+'
        )
      ),
      suffix = dplyr::case_when(
        question_id %in% matrix_question_ids ~ stringr::str_remove(suffix, '^[0-9]+_?'),
        TRUE ~ suffix
      )
    )


  # Choices -----------------------------------------------------------------

  # last part! Think I'm content to just assume any leftover numbers
  # in the suffix are choices:

  column_map = column_map %>%
    dplyr::mutate(
      choice = stringr::str_extract(
        string = suffix,
        pattern = '^[0-9]+_?'
      ),
      choice = as.integer(
        stringr::str_extract(
          string = choice,
          pattern ='[0-9]+'
        )
      ),
      suffix = stringr::str_remove(
        string = suffix,
        pattern = '^[0-9]+_?'
      )
    )

  # Now we need to join BOTH the choices and the choice_recodes because
  # for whatever reason Qualtrics exports both in differen circumstances:
  column_map = column_map %>%
    dplyr::left_join(
      dplyr::transmute(
        flattened_survey[['choices']],
        question_id,
        column_number,
        choice,
        choice_recode2 = choice_recode
      ),
      by = c('question_id', 'column_number', 'choice')
    )

  column_map = column_map %>%
    dplyr::left_join(
      dplyr::transmute(
        flattened_survey[['choices']],
        question_id,
        column_number,
        choice2 = choice,
        choice_recode
      ) %>%
        dplyr::filter(!is.na(choice_recode)),
      by = c('question_id', 'column_number', 'choice_recode')
    ) %>%
    dplyr::mutate(
      choice_recode = dplyr::coalesce(choice_recode, choice_recode2),
      choice = dplyr::coalesce(choice, choice2),
      choice = dplyr::coalesce(choice, choice_recode)
    )


  # Shouldn't be any numbers remaining as far as I know:
  if(
    any(
      stringr::str_detect(
        string = column_map[['suffix']],
        pattern = '[0-9]'
      )
    )
  ){
    stop('residual numbers found in suffix')
  }


  # Text entry --------------------------------------------------------------

  column_map = column_map %>%
    dplyr::mutate(
      text_entry = as.integer(
        stringr::str_detect(
          string = suffix,
          pattern = 'TEXT'
        )
      ),
      suffix = stringr::str_remove(
        string = suffix,
        pattern = '_TEXT'
      )
    )


  # Nice suffix -------------------------------------------------------------

  # now we use all that data we extracted to make the coded suffix:
  column_map = column_map %>%
    dplyr::mutate(
      LP = dplyr::case_when(
        !is.na(loop_number) ~ paste0('_LP', pad2(loop_number)),
        TRUE ~ ''
      ),
      CL = dplyr::case_when(
        !is.na(column_number) ~ paste0('_CL', pad2(column_number)),
        TRUE ~ ''
      ),
      SQ = dplyr::case_when(
        !is.na(subq_number) ~ paste0('_SQ', pad2(subq_number)),
        TRUE ~ ''
      ),
      CH = dplyr::case_when(
        !is.na(dplyr::coalesce(choice_recode, choice)) ~ paste0(
          '_CH', pad2(dplyr::coalesce(choice_recode, choice))
        ),
        TRUE ~ ''
      ),
      suffix = dplyr::case_when(
        suffix != '' ~ paste0('_', suffix),
        TRUE ~ ''
      ),
      suffix = paste0(CL, SQ, CH, suffix)
    )

  # Question names -------------------------------------------------------------

  # Now we're on to styling up our custom names:
  question_names = flattened_survey[['blocks']] %>%
    dplyr::select(block_description, block_id) %>%
    dplyr::left_join(
      y = dplyr::select(flattened_survey[['questions']], question_id, block_id),
      by = 'block_id'
    ) %>%
    # repeats on column_number and subq_number mean we wanna grind this down:
    dplyr::distinct(block_description, block_id, question_id) %>%
    dplyr::group_by(block_id) %>%
    dplyr::mutate(
      question_num = pad2(dplyr::row_number())
    ) %>%
    dplyr::ungroup() %>%
    dplyr::transmute(
      question_name = paste0(
        block_description,
        '_',
        question_num
      ),
      question_id
    )

  column_map = dplyr::right_join(
    x = question_names,
    y = column_map,
    by = 'question_id'
  )


  # Clean up ----------------------------------------------------------------

  # now we just attach the question name and suffix
  column_map = column_map %>%
    dplyr::transmute(
      exported_column,
      default_column = paste0(question_name, suffix),
      exported_description,
      question_id,
      import_id,
      question_name,
      suffix,
      loop_number,
      column_number,
      subq_number,
      choice,
      choice_recode,
      text_entry
    )


  # Check -------------------------------------------------------------------

  if(nrow(column_map) != column_map_nrow){
    stop('number of rows in column_map is off!')
  }

  column_map

}





